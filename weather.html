<!-- Team
	Connor Boyle - cjb703
	Paromita Sengupta - pas682
 -->
<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<title>Weather</title>
	<script type="text/javascript" src="d3.v5.min.js"></script>
	<script src="https://d3js.org/d3-color.v1.min.js"></script>
	<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
	<style>
		html,
		body {
			width: auto;
			height: auto;
		}

		.graph {
			width: 60vw;
			height: 92vh;
			overflow: auto;
		}
	</style>
</head>

<body>
	<form>
		<label for="cbxALBEDO">Albedo</label>
		<input id="cbxALBEDO" name="cbxALBEDO" type="checkbox" checked></input>
		&nbsp;
		&nbsp;
		<label for="cbxEMISS">Emissivity</label>
		<input id="cbxEMISS" name="cbxEMISS" type="checkbox"></input>
		&nbsp;
		&nbsp;
		<label for="cbxGRDFLX">Ground Flux</label>
		<input id="cbxGRDFLX" name="cbxGRDFLX" type="checkbox"></input>
		&nbsp;
		&nbsp;
		<label for="cbxSMOIS">Soil Moisture</label>
		<input id="cbxSMOIS" name="cbxSMOIS" type="checkbox"></input>
	</form>
	<br />
	<div class="graph">
		<span class="map"></span>
		<span class="plot"></span>
	</div>
	<div class="legend"></div>

	<script type="text/javascript">
		var mult = 2; // multiplier for pixel size
		var pixelize = false; // whether to skip 'odd' rows in the csv

		var nodes = [];

		var width = 0;
		var height = 0;

		var maxAlbedo = Number.MIN_VALUE;
		var minAlbedo = Number.MAX_VALUE;
		var maxEmiss = Number.MIN_VALUE;
		var minEmiss = Number.MAX_VALUE;
		var maxGrdFlx = Number.MIN_VALUE;
		var minGrdFlx = Number.MAX_VALUE;
		var maxSMois = Number.MIN_VALUE;
		var minSMois = Number.MAX_VALUE;

		// Read the two data files
		d3.csv("weather-canada.csv").then(data => {
			data.forEach(n => {
				if (pixelize && (n.x % 2 != 0 || n.y % 2 != 0))
					return;
				n.x = parseInt(n.x);
				if (n.x > width) width = n.x;
				n.y = parseInt(n.y);
				if (n.y > height) height = n.y;
				n.ALBEDO = parseFloat(n.ALBEDO);
				if (n.ALBEDO < minAlbedo) minAlbedo = n.ALBEDO;
				if (n.ALBEDO > maxAlbedo) maxAlbedo = n.ALBEDO;
				n.EMISS = parseFloat(n.EMISS);
				if (n.EMISS < minEmiss) minEmiss = n.EMISS;
				if (n.EMISS > maxEmiss) maxEmiss = n.EMISS;
				n.GRDFLX = parseFloat(n.GRDFLX);
				if (n.GRDFLX < minGrdFlx) minGrdFlx = n.GRDFLX;
				if (n.GRDFLX > maxGrdFlx) maxGrdFlx = n.GRDFLX;
				n.SMOIS = parseFloat(n.SMOIS);
				if (n.SMOIS < minSMois) minSMois = n.SMOIS;
				if (n.SMOIS > maxSMois) maxSMois = n.SMOIS;
				nodes.push(n);
			});
			Promise.all([
				new Promise((rs, rj) => generateMap()),
				new Promise((rs, rj) => generateLegend()),
				new Promise((rs, rj) => generatePlot())
			]);
		});

		async function generateMap() {
			var visibleEdges = [];
			var visibleNodes = nodes;

			d3.select("body .graph .map svg").remove();
			var svg = d3.select("body .graph .map")
				.append("svg")
				.attr("width", mult * height)
				.attr("height", mult * width)
				.attr("pointer-events", "all");


			var xScale = d3.scaleLinear()
				.domain([0, width])
				.range([0, mult * width]);

			var yScale = d3.scaleLinear()
				.domain([0, height])
				.range([0, mult * height]);

			// var colorScale = d3.scaleSequential(d3.interpolateInferno)
			var colorScale = d3.scaleSequential(d3.interpolateCubehelixDefault)
				.domain([minEmiss, maxEmiss]);

			// add circles for countries
			svg.selectAll("rect").data(visibleNodes).enter()
				.append("rect")
				.attr("x", n => yScale(n.y))
				.attr("y", n => xScale(width - n.x))
				.attr("width", n => mult * (pixelize ? 2 : 1))
				.attr("height", n => mult * (pixelize ? 2 : 1))
				.attr("strokeWidth", 0)
				// .attr("stroke", "black")
				.attr("fill", n => colorScale(n.EMISS))
				.on("hover", n => {

				});
		}

		async function generateLegend() {

		}

		async function generatePlot() {

		}
	</script>
</body>

</html>