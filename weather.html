<!-- Team
	Connor Boyle - cjb703
	Paromita Sengupta - pas682
 -->
<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<title>Weather</title>
	<script type="text/javascript" src="d3.v5.min.js"></script>
	<script src="https://d3js.org/d3-color.v1.min.js"></script>
	<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
	<style>
		html,
		body {
			width: auto;
			height: auto;
			font-family: Arial, Helvetica, sans-serif;
			background-color: lightgoldenrodyellow;
		}

		.graph {
			width: auto;
			height: auto;
			overflow: auto;
		}

		.graph.map {
			border: 1px solid black;
		}

		div.tooltip {
			position: absolute;
			padding: .5rem;
			background: white;
			color: black;
			border: 1px solid black;
			pointer-events: none;
		}

		div.legend {
			text-align: center;
		}

		div.legend img {
			border: 1px solid black;
		}
	</style>
</head>

<body>
	<form>
		<label for="cbxALBEDO">Albedo</label>
		<input id="cbxALBEDO" name="cbxALBEDO" type="checkbox" checked></input>
		&nbsp;
		&nbsp;
		<label for="cbxEMISS">Emissivity</label>
		<input id="cbxEMISS" name="cbxEMISS" type="checkbox"></input>
		&nbsp;
		&nbsp;
		<label for="cbxGRDFLX">Ground Flux</label>
		<input id="cbxGRDFLX" name="cbxGRDFLX" type="checkbox"></input>
		&nbsp;
		&nbsp;
		<label for="cbxSMOIS">Soil Moisture</label>
		<input id="cbxSMOIS" name="cbxSMOIS" type="checkbox"></input>
		&nbsp;
		&nbsp;
		&nbsp;
		<img id="loader" src="ajax-loading-gif-transparent-background-2.gif" width="15" height="15" />
	</form>
	<br />
	<div class="graph">
		<span class="map"></span>
	</div>
	<br />
	<div class="legend" style="width: fit-content;">
		<img src="https://raw.githubusercontent.com/d3/d3-scale-chromatic/master/img/inferno.png" height="50">
		<div style="width: 100%;">
			<span style="float: left;">0%</span>
			<span id="legendTag"></span>
			<span style="float: right;">100%</span>
		</div>
	</div>

	<script type="text/javascript">
		var mult = 1.5; // multiplier for pixel size
		var pixelize = true; // whether to skip 'odd' rows in the csv

		var nodes = [];

		var width = 0;
		var height = 0;

		var maxAlbedo = Number.MIN_VALUE;
		var minAlbedo = Number.MAX_VALUE;
		var maxEmiss = Number.MIN_VALUE;
		var minEmiss = Number.MAX_VALUE;
		var maxGrdFlx = Number.MIN_VALUE;
		var minGrdFlx = Number.MAX_VALUE;
		var maxSMois = Number.MIN_VALUE;
		var minSMois = Number.MAX_VALUE;

		var maximum = Number.MIN_VALUE;
		var minimum = Number.MAX_VALUE;
		var multipleSelections = false;

		function percentRange(t) {
			var val = t[0];
			var min = t[1];
			var max = t[2];
			return ((val - min)) / (max - min);
		}

		function correlate(tuples) {
			if (tuples.length === 1) {
				return percentRange(tuples[0]);
			}
			var sum = 0;
			for (let i = 0; i < tuples.length - 1; i++) {
				let t1 = tuples[i];
				for (let j = i; j < tuples.length; j++) {
					if (i !== j) {
						t2 = tuples[j];
						sum += 1 - Math.abs(percentRange(t1) - percentRange(t2));
					}
				}
			}
			return sum / tuples.length;
		}

		function parseDataValues(n) {
			var visibleData = [];
			if (document.getElementById("cbxALBEDO").checked) {
				d3.select("#legendTag").html("Albedo")
				visibleData.push([n.ALBEDO, minAlbedo, maxAlbedo]);
			}
			if (document.getElementById("cbxEMISS").checked) {
				d3.select("#legendTag").html("Emissivity")
				visibleData.push([n.EMISS, minEmiss, maxEmiss]);
			}
			if (document.getElementById("cbxGRDFLX").checked) {
				d3.select("#legendTag").html("Ground Flux")
				visibleData.push([n.GRDFLX, minGrdFlx, maxGrdFlx]);
			}
			if (document.getElementById("cbxSMOIS").checked) {
				d3.select("#legendTag").html("Soil Moisture")
				visibleData.push([n.SMOIS, minSMois, maxSMois]);
			}

			if (visibleData.length > 1) {
				d3.select("#legendTag").html("Correlation");
				multipleSelections = true;
			} else {
				multipleSelections = false;
			}

			return correlate(visibleData);
		}

		// Read the data file
		d3.csv("weather-lower-canada.csv").then(data => {
			data.forEach(n => {
				if (pixelize && (n.x % 2 != 0 || n.y % 2 != 0))
					return;
				n.x = parseInt(n.x);
				if (n.x > width) width = n.x;
				n.y = parseInt(n.y);
				if (n.y > height) height = n.y;
				n.ALBEDO = parseFloat(n.ALBEDO);
				if (n.ALBEDO < minAlbedo) minAlbedo = n.ALBEDO;
				if (n.ALBEDO > maxAlbedo) maxAlbedo = n.ALBEDO;
				n.EMISS = parseFloat(n.EMISS);
				if (n.EMISS < minEmiss) minEmiss = n.EMISS;
				if (n.EMISS > maxEmiss) maxEmiss = n.EMISS;
				n.GRDFLX = parseFloat(n.GRDFLX);
				if (n.GRDFLX < minGrdFlx) minGrdFlx = n.GRDFLX;
				if (n.GRDFLX > maxGrdFlx) maxGrdFlx = n.GRDFLX;
				n.SMOIS = parseFloat(n.SMOIS);
				if (n.SMOIS < minSMois) minSMois = n.SMOIS;
				if (n.SMOIS > maxSMois) maxSMois = n.SMOIS;
				nodes.push(n);
			});
			Promise.all([
				new Promise((rs, rj) => generateMap()),
				new Promise((rs, rj) => generateLegend()),
				new Promise((rs, rj) => generatePlot())
			]);
		});

		async function generateMap() {
			d3.select("#loader").style("opacity", "1");

			nodes.forEach(n => {
				n.VALUE = parseDataValues(n);
				if (n.VALUE < minimum) minimum = n.VALUE;
				if (n.VALUE > maximum) maximum = n.VALUE;
			});

			d3.select("body .graph .map svg").remove();
			d3.select("body #tooltip").remove();
			var svg = d3.select("body .graph .map")
				.append("svg")
				.attr("width", mult * height)
				.attr("height", mult * width)
				.attr("pointer-events", "all");

			var xScale = d3.scaleLinear()
				.domain([0, width])
				.range([0, mult * width]);

			var yScale = d3.scaleLinear()
				.domain([0, height])
				.range([0, mult * height]);

			var tooltip = d3.select("body").append("div")
				.attr("class", "tooltip")
				.style("opacity", 0);

			var colorScale = d3.scaleSequential(d3.interpolateInferno)
				// var colorScale = d3.scaleSequential(d3.interpolateCubehelixDefault)
				.domain([minimum, maximum]);
			// .domain([minEmiss, maxEmiss]);

			// add circles for countries
			svg.selectAll("rect").data(nodes).enter()
				.append("rect")
				.attr("x", n => yScale(n.y))
				.attr("y", n => xScale(width - n.x))
				.attr("width", n => mult * (pixelize ? 2 : 1))
				.attr("height", n => mult * (pixelize ? 2 : 1))
				.attr("strokeWidth", 0)
				// .attr("stroke", "black")
				.attr("fill", n => colorScale(n.VALUE))
				.on("mouseover", n => {
					var text = "<div><strong>ALBEDO</strong>: " + (Math.round(n.ALBEDO * 1000) / 1000) + "</div>";
					text += "<div><strong>EMISS</strong>: " + (Math.round(n.EMISS * 1000) / 1000) + "</div>";
					text += "<div><strong>GRDFLX</strong>: " + (Math.round(n.GRDFLX * 1000) / 1000) + " W\u1427m<sup>-2</sup></div>";
					text += "<div><strong>SMOIS</strong>: " + (Math.round(n.SMOIS * 1000) / 1000) + "</div>";
					if (multipleSelections) {
						text += "<hr/>"
						text += "<div><strong>CORRL</strong>: " + (Math.round(n.VALUE * 10000) / 100) + " %</div>";
					}
					tooltip.html(text)
						.style("left", (d3.event.pageX + 10) + "px")
						.style("top", (d3.event.pageY + 10) + "px")
						.style("opacity", 1);
				})
				.on("mouseout", n => {
					tooltip.html("").style("opacity", 0);
				});

			d3.select("#loader").style("opacity", 0);
		}

		var form = document.querySelector("form")
		form.addEventListener("change", () => {
			generateMap();
			generateLegend();
			generatePlot();
		});
	</script>
</body>

</html>